# T-SMOTE: *Temporal-oriented Synthetic Minority Oversampling Technique for Imbalanced Time Series Classification*

T-SMOTE is more than a conventional oversampling algorithm - it represents a shift in how we approach data imbalance in time-series classification.
While traditional techniques like SMOTE operate on static, tabular data by interpolating between isolated samples, they overlook a crucial aspect of sequential data: temporal continuity.

T-SMOTE introduces a time-aware framework that respects the evolving nature of time-series signals. Instead of treating each observation independently, it generates synthetic sequences that follow the real-world dynamics of events - maintaining both structural integrity and chronological order.

> [üîó Read the paper on IJCAI](https://www.ijcai.org/proceedings/2022/0431.pdf)

---

## SMOTE vs T-SMOTE

Traditional SMOTE (Synthetic Minority Oversampling Technique) works by linearly interpolating between existing minority samples:

x_new = x_i + Œª √ó (x_j ‚àí x_i),‚ÄÉwhere Œª ‚àà [0, 1]


This approach is effective for tabular datasets, where each record is independent.  
However, when applied to time-series data, it breaks down due to several key issues:

- **Loss of temporal order**: Flattening sequences into feature vectors destroys the natural timeline of the data.
- **Unrealistic transitions**: Interpolation mixes values across unrelated timestamps, producing distorted signals.
- **No temporal context**: Trends, anomalies, and event progressions are ignored, making generated samples unreliable.

T-SMOTE addresses these limitations by introducing temporal awareness.  
Instead of interpolating between random samples, it mixes adjacent windows from the same time-series sequence ‚Äî guided by model confidence.  
This creates synthetic sequences that not only balance the dataset but also reflect how real events unfold over time.

---

## How T-SMOTE Works - Step by Step

T-SMOTE generates temporally consistent synthetic samples by following a structured pipeline. Here's how it works:

### 1. Slice Sequences into Leading-Time Windows

Each positive sample (e.g., a time-series before failure) is divided into overlapping windows of fixed length `w`, sliding backward from the event.  
Each window is defined by its leading time `l`, which controls how far it ends before the event.

For example:
- `l = 0` gives the last window (closest to the event),
- `l = 1` gives the one just before that, and so on.

This creates a series of windows: `X‚ÅΩ‚Å∞‚Åæ`, `X‚ÅΩ¬π‚Åæ`, ..., `X‚ÅΩÀ°‚Åæ`.

### 2. Score Each Window Using a Classifier

A classifier is trained on the original dataset (no synthetic data yet).  
Each window is passed through the classifier to estimate how "positive" it looks ‚Äî that is, how likely it belongs to the minority class.

As windows move further from the event (increasing `l`), their scores typically decrease.

### 3. Apply the Spy-Based Threshold to Define Near-Border Windows

To avoid going too far back in time, T-SMOTE uses a spy-based approach to determine a cutoff `L`:

- Randomly select a small portion (e.g., 15%) of negative samples and relabel them as temporary "spies".
- Retrain the classifier with these spies included as positives.
- The highest score among the spies defines a threshold `h`.
- For each `l`, compute the average score across all windows `X‚ÅΩÀ°‚Åæ`.
- Stop at the first `l` where this average drops below `h`; set `L = l - 1`.

Only windows up to `l = L` are kept. These are considered "near-border" positive windows ‚Äî close enough to the event to remain informative, but not so early as to drift into the negative class.

### 4. Interpolate Between Temporal Neighbors

Synthetic samples are generated by interpolating between consecutive windows from the same sequence (e.g., `X‚ÅΩÀ°‚Åæ` and `X‚ÅΩÀ°‚Å∫¬π‚Åæ`), not random samples.  
The mixing coefficient Œ± is drawn from a Beta distribution shaped by their classifier scores:

X_new = Œ± √ó X‚ÅΩÀ°‚Åæ + (1 ‚àí Œ±) √ó X‚ÅΩÀ°‚Å∫¬π‚Åæ

Œ± ~ Beta(score‚ÅΩÀ°‚Åæ, score‚ÅΩÀ°‚Å∫¬π‚Åæ)


This ensures the synthetic sequence follows a natural, confident progression over time.

### 5. Filter with Weighted Sampling

Not all synthetic windows are equally useful.  
T-SMOTE computes a weight for each new sample based on how far its interpolated score lies above the spy threshold `h`:

weight = max(0, score_new ‚àí h)


Only high-confidence synthetic samples are retained ‚Äî minimizing noise and improving the quality of the augmented dataset.

---

This pipeline allows T-SMOTE to generate high-quality, realistic samples that preserve both the statistical and temporal integrity of the original time-series data.
